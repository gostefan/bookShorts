\documentclass[a4paper, twocolumn]{article}

\usepackage{amsmath, amsthm, amssymb, amsfonts} 
\usepackage{color}
\usepackage[utf8]{inputenc}
\usepackage{multirow}
\usepackage{graphics}
\usepackage[pdftex]{hyperref}
\usepackage{moreverb}

\usepackage[novbox]{pdfsync}

\title{Summary: Effective C++ \\
	\large
	55 Specific Ways to Improve Your Programs and Designs
	Scott Meyers}
\author{Stefan GÃ¶tschi}

% Commands

\let\oldsubsection\subsection

\newcounter{mysubsection}
\renewcommand{\subsection}{
    \stepcounter{mysubsection}
    \oldsubsection
}
\renewcommand{\thesubsection}{\arabic{mysubsection}.}

\definecolor{lightgrey}{rgb}{0.96,0.96,0.96}
\newcommand{\code}[1]{\texttt{\color{black}{#1}}}
\newcommand{\keyword}[1]{\textbf{\color{black}{#1}}}
\newcommand{\example}[1]{\textbf{\medskip\colorbox{lightgrey}{\color{black}{Beispiel: #1}}}}

\begin{document}
\maketitle

\section{Accustoming Yourself to C++}

\subsection{View C++ as a federation of languages}
There are several aspects of C++: C, Object-Oriented C++, Template C++, STL, and even more. The approaches to write efficient C++ vary from aspect to aspect.

\subsection{Prefer \code{const}s, \code{enum}, \code{inline}s to \code{\#define}s}
Whenever possible avoid \code{\#include}. If it's a global constant just use a \code{const} variables in anonymous namespaces. (if you have pointers don't forget to write const twice.) The advantage of this is that using \code{static const} members of classes have limited accessibilty.\\
There is a point about hacking around a limitation of old compilers not accepting initial values in declaration. When you need that you can use an enum which can have a defined value. But don't do this if you work with current compilers.\\
Another point is that you can get rid of macros that replace function calls by using templates at no runtime cost.\\
One point that is missing in the book is that you should use macros as seldomly as possible as IDEs sometimes have a hard time to follow them and an even harder one to refactor them.

\subsection{Use \code{const} whenever possible}
You can easily make pointers and objects immutable using \code{const}. This might allow you to find certain bugs at compile time already. But always be aware of what exactly is const (\code{const T*} vs. \code{T* const}).\\
It is prudent to make return types from operators const as otherwise you could assign to the result of an operation.\\
If you have to write a \code{const} and a non-\code{const} member function you typically do code duplication. If you want to avoid that in the non-\code{const} function call the \code{const} function and cast away the \code{const} on the return value. (Don't forget to cast \code{this} to a const object to get the other implementation.

\subsection{Make sure that objects are initialized before they're used}
Either read up on when your data is guaranteed to be initialized or always initialize all your data.\\
Don't misunderstand initializing with assignment. This easily happens in class constructors. The problem is not with built in data types butwith user-defined types which will first be default constructed and then assigned to.\\
There is a tip to use private functions to initialize class members if too many constructors exist. But this is not accurate anymore - the current approach for this is to use delegating constructors.\\
Another thing are static objects. To get around the problem of the right initialization order we can put them as static variables into functions where they will be initialied before they are used. Until recently this was not thread safe but most compilers guarantee thread safe initialization now.
\newpage

\section{Constructors, Destructors, and Assignment Operators}

\subsection{Know what functions C++ silently writes and calls}
If you don't write the functions on your own C++ will write some for you.
\begin{verbatim}
class Empty{};
\end{verbatim}
becomes
\begin{verbatim}
class Empty {
  public:
    Empty() {...} // default constructor
    Empty(const Empty& rhs) {...}
                    // copy constructor
    Empty(Empty&& rhs) {...}
                    // move constructor
    ~Empty() {...} // destructor
    Empty& operator=(const Empty& rhs)
              {...} // copy assignment
    Empty& operator=(Empty&& rhs)
              {...} // move assignment
}
\end{verbatim}
This is augmented from the book's version which covers C++ from pre C++11 / move semantics.

The created constructors and assignment operators just copy/assign/move all the members from the other object.

But the compiler will only create these functions for you if the created code is legal and it has any chance of making sense. This means that if you use a reference or \code{const} member these functions will not be created.

\subsection{Explicitly disallow the use of compiler-generated function you do not want}
Some objects should not be copyable and you'd like the error to arise at compile time already.\\
The book proposes to make the copy constructor and copy assignment operator \code{private} and not implement them. This prohibits all other code to use them and if someone were to use them inside the class compilation would fail at link time.\\
You could also have a base class that defines these functions private and inherit from it to make this more explicit.

Not covered by the book is that modern C++ has a cleaner approach to this: you can delete unwanted functions:
\begin{verbatim}
	class NoCopy {
	  public:
	    NoCopy() {...}
	    NoCopy(const NoCopy&) = delete;
	    NoCopy& operator=(const NoCopy&)
	                          = delete;
	}
\end{verbatim}
With modern C++ you might think about declaring a move constructor and assinment operator. This doesn't copy your object but moves it around.

\subsection{Declare destructors virtual in polymorphic base classes}
Assume you have a file system interface that hides all the specialities of each operating system. There is a factory function that returns you a pointer to an object of the interface type with the contract that you delete that pointer after use.\\
If your destructor is non-virtual \code{delete} C++ specifies undefined behavior - typically that only destroys the base class part while the derived part is never destroyed.\\
The easy solution to get around this is to define the destructor \code{virtual}. With this the call to the base class destructor will be dynamically dispatched and routed to the derived class destructor (which in turn calls the base's destructor).

If a class does not define a virtual destructor it is often not meant to extended. Although the reasons for not declaring a \code{virtual} destructor might be different as well:
\begin{itemize}
	\item Not declaring any virtual functions enables you to pass your objects to languages like C or FORTRAN as they don't know \code{virtual}.
	\item Having \code{virtual} functions in an object increases the size of that object by one pointer (typically).
\end{itemize}
This means that in gener you declare a \code{virtual} destructor if your class has at least one \code{virtual} function.

Be aware that standard library classes like \code{string}, \code{vector}, \code{map}, etc. all don't have a \code{virtual} destructor.

Declare a pure \code{virtual} destructor if you are declaring an abstract class that has no abstract functions - that makes it abstract.\\
But be aware that a definition of the destructor is necessary anyway. The compiler will generate a call to the base class's destructor from each derived class's destructor.

\subsection{Prevent exceptions from leaving destructors}
Say you have a database connection class \code{DbConnection}. The conneciton is established in the constructor and closed in the destructor.\\
What happens if the connection cannot be closed - e.g. because the connection is lost? You throw an exception which the calling code needs to handle?\\
For normal code flow this seems fine and testing will make it seem ok. But if your connection's destructor is called because another exception unwinds the stack throwing another excpetion is trouble - C++ either defines program termination or undefined behavior.\\

There are two primary ways to resolve this issue:
\paragraph{Terminate the program}
If you are at a point where you want to throw an exception in the destructor and you cannot continue normal execution then (log the error and) terminate the program the proper way (\code{std::abort();}).
\paragraph{Swallow the exception}
Sometimes it's better though to (log and) swallow an exception than to have/run the risk of premature program termination.
\paragraph{}
An alternative approach would be to extract the functionality in the destructor to a funciton - e.g. \code{close} that may throw. That way the client can handle the exception if he wants to. And if \code{clode} wasn't called on object destruction the destructor will call it and use one of the above approaches to handle the exception.

\subsection{Never call virtual functions during construction or destruction}

\subsection{Have assignment operators return a reference to \code{*this}}

\subsection{Handle assignment to self in \code{operator=}}

\subsection{Copy all parts of an object}
\newpage

\section{Resource Management}

\subsection{Use objects to manage resources}

\subsection{Think carefully about copying behavior in resource-managing classes}

\subsection{Provide access to raw resources in resource-managing classes}

\subsection{Use the same form in corresponging uses of \code{new} and \code{delete}}

\subsection{Store \code{new}ed objects in smart pointers in standalone statements}
\newpage

\section{Designs and Declarations}

\subsection{Make interface easy to use correctly and hard to use incorrectly}

\subsection{Treat \code{class} design as type design}

\subsection{Prefer pass-by-reference-to-\code{const} to pass-by-value}

\subsection{Don't try to return a reference when you must return an objects}

\subsection{Declare data members \code{private}}

\subsection{Prefer non-member non-friend functions to member functions}

\subsection{Declare non-member functions when type converstions should apply to all parameters}

\subsection{Consider support for a non-throwing \code{swap}}
\newpage

\section{Implementations}

\subsection{Postpone variable definitions as long as possible}

\subsection{Minimize casting}

\subsection{Avoid returning "handles" to object internals}

\subsection{Strive for exception-safe code}

\subsection{Understand the ins and outs of inlining}

\subsection{Minimize compilation dependencies between files}
\newpage

\section{Inheritance and Object-Oriented Design}

\subsection{Make sure public inheritance models "is-a".}

\subsection{Avoid hiding inherited names}

\subsection{Differentiate between inheritance of interface and inheritance of implementation}

\subsection{Consider alternatives to virtual functions}

\subsection{Never redefine an inherited non-virtual function}

\subsection{Never redefine a function's inherited default parameter value}

\subsection{Model "has-a" or "is-implemented-in-terms-of" through composition}

\subsection{Use private inheritance judiciously}

\subsection{Use multiple inheritance judiciously}
\newpage

\section{Templates and Generic Programming}

\subsection{Understand implicit interfaces and compile-time polymorphism}

\subsection{Understand the two meanings of \code{typename}}

\subsection{Know how to access names in templatized base classes}

\subsection{Factor parameter-independent code out of templates}

\subsection{Use member function templates to accept "all compatible types"}

\subsection{Define non-member functions inside templates when type conversions are desired}

\subsection{Use traits classes for information about types}

\subsection{Be aware of template metaprogramming}
\newpage

\section{Customing \code{new} and \code{delete}}

\subsection{Understand the behavior of the \code{new}-handler}

\subsection{Understand when it makes sense to replace \code{new} and \code{delete}}

\subsection{Adhere to convention when writing \code{new} and \code{delete}}

\subsection{Write placement \code{delete} if you write placement \code{new}}
\newpage

\section{Miscellany}

\subsection{Pay attention to compiler warnings}

\subsection{Familiarize yourself with the standard library, including \code{TR1}}

\subsection{Familiarize yourself with Boost}
\newpage

\section{Beyond Effective C++}


\end{document}
