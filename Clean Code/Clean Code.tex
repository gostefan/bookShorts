\documentclass[a4paper, twocolumn]{article}

\usepackage{amsmath, amsthm, amssymb, amsfonts} 
\usepackage{color}
%\usepackage{german}
\usepackage[utf8]{inputenc}
%\usepackage{multicol}  
\usepackage{multirow}
%\usepackage{dsfont} 
%\usepackage[rflt]{floatflt}  
\usepackage{graphics}
\usepackage{epsfig} 
\usepackage[pdftex]{hyperref}
\usepackage{moreverb}

\usepackage[novbox]{pdfsync}

\title{Summary: Clean Code \\
	\large
	A Handbook of Agile Software Craftsmanship
	Robert C. Martin}
\author{Stefan GÃ¶tschi}

% Commands

\definecolor{lightgrey}{rgb}{0.96,0.96,0.96}
\newcommand{\code}[1]{\texttt{\color{black}{#1}}}
\newcommand{\keyword}[1]{\textbf{\color{black}{#1}}}
\newcommand{\example}[1]{\textbf{\medskip\colorbox{lightgrey}{\color{black}{Beispiel: #1}}}}

\begin{document}
\maketitle

\section{Principles, Patterns and \\ Practices of Clean Code}

\subsection{Clean Code}
\paragraph{Why clean code?}
It happens so easily - you just have to finish something and don't do it cleanly. Your code is a little messy. The next day you encounter some messy code and have to hack your feature around that part of code because you don't understand it. Afterwards the code is even messier.

The problem starts if you're not able to break this cycle and your code base degrades more and more. The cost of this mess isn't visible today as it works right now. But when you need to hack more and more workarounds so the mess still works you get slowed down. This gets worse and worse to the point where you're just struggling with your code and not achieving anything anymore.

Then you might consider a grand redesign. As you cannot stop adding new features for years you will have to develop the new version while still adding to the old one. So you have two teams racing each other. As this goes on it can happen that the new system also starts to be a mess and in the end you're not better off.

But the fault for this is clearly with us programmers. We have schedules and deadlines of course. But in the end it's our job to deliver good quality code and not just something that works. We need to help draw up plans and schedules with project managers instead of letting them guess timelines.

It is important to have your code readable as code will be read about ten times more often then changed.

This is nicely summarized in the Boy Scouts rule: "Leave the campground cleaner than you found it."

\paragraph{Definition}
The definition of clean code on the other hand is hard to get. Here are some parts to it.
\begin{description}
	\item[Elegant] The code should be pleasing to read like a good book.
	\item[Efficient] It's not only about speed - typically wasted cycles a sign of inelegancy, of something that should be done differently. It also inefficient code tempts for optimization that might make a mess again.
	\item[Error handling complete] Pay attention to details and do proper error handling.
	\item[Does one thing well] Good code is focussed on what it does and doesn't do anything else.
	\item[Obvious] You can see the intentions of the author. There is nothing hidden behind obscure lines or complicated mathematical formulae. What is done should always feel straightforward.
	\item[Other authors] It should be easy for anyone to change something in the code. Furthermore it should be easy to do it right and hard to do it wrong.
	\item[Tested] It is not clean to have code without tests. Without them it is incomplete. Like a mathematical statement without proof.
	\item[Minimal API] Whenever you could remove something from your API and were still able to do everything your code will not be clean as it contains duplication.
	\item[Done with care] There are no (easy) improvements as the author already did all of them.
	\item[Without duplication] If you do one thing twice one of the two might be flawed. One might be improved and the other not while being still used.
\end{description}

\subsection{Meaningful Names}
It is important to chose names wisely as they reveal what the content actually represents. Again some important points:
\begin{description}
	\item[Intention-Revealing] It makes it much easier to understand and change code if you understand the intention. This may be a variable or function name just as well as a class name as well as class names used to show what it represents.
	\item[Avoid Disinformation]\mbox{} \\ [-1.5\baselineskip]
		\begin{itemize}
			\item Abbreviations can be hard to see through if you're not deep into the current code.
			\item It might be hard to understand differences between \code{account}, \code{theAccount} and \code{accountInfo}.
			\item If you use accountList for an array of accounts someone else migth assume that it actually is a List and not an Array.
			\item Use distinctive names that don't only separate by a few small characters.
			\item Don't use \code{O} (uppercase o) as variable name as it is easily confused with \code{0} (zero). The same gose for \code{l} and \code{1}.
		\end{itemize}
	\item[Meaningful Distinctions] Don't misspell classes (e.g. \code{clazz}), add numbers (e.g. \code{a1}, \code{a2}, ...), or add noise words (e.g. \code{...Info},  \code{...Data}) just because names clash - make a distinction between the two variables, functions, or classes as they do something else.\\
		Don't use words like \code{variable}, \code{table}, or \code{string} for variables, tables, or strings.
	\item[Pronounceable Names] We can read words better than abbreviations or worse first letter concatenations. It's a bad idea to use \code{ymdhmi} for year, month, date, hour, minute, second for example - rather use timestamp.
	\item[Searchable Names] Don't use plane numbers - create constants with meaningful names and use those. It both shows intent and is searchable.
	\item[Name length $\sim$ scope size] The length of names (in characters) should correspond to the size of the scope they are used in.
	\item[Avoid encodings] Don't use encodings in names: Drop all type descriptions, memberPrefixes (\code{m...}, \code{m\_...}) and interface prefixes (\code{I...} - use \code{...Imp} if necessary) - this information is easily supplied by the IDE.
	\item[Mental Mapping] Single letter names are only ok for loop variables \code{i}, \code{j}, or \code{k} (but not \code{l}).
	\item[Class Names] should be a noun or noun phrase - never a verb. Avoid \code{Manager}, \code{Processor}, \code{Data}, or \code{Info}.
	\item[Method Names] should be a verb or verb phrase - never a noun. Consider static factory methods with names for overloaded constructors to describe the arguments.
	\item[Don't be cute] say what you mean and not what sounds cute and funny. (E.g. don't use \code{eatMyShorts} instead of \code{abort()}.)
	\item[One Word per Concept] One high level concept should have one name. E.g. don't use \code{get}, \code{fetch} and \code{retrieve} interchangeably. Use the same word when the semantics are the same.
	\item[Don't pun] Basically the inverse of the last one. E.g. Don't use \code{add} for adding to collections as well as adding numbers. Use two words when the semantics differ.
	\item[Solution Domain] Your code will be read by computer scientists. So write in their terms: Name patterns, algorithms, math etc. Be technical.
	\item[Problem Domain] If there is no typical programmer word use words that someone working in the domain recognizes. Then the programmer can get help to understand the code.
	\item[Add Context] Only few names make sense of their own. \code{name} only tells you what is named from the context. If there is no context you might consider prefixing: \code{bookName}. Be aware that long functions may break context.
	\item[Too much Context] Don't add too much context. E.g. only prefix address if you have to store different addresses. Shorter names are better than long ones.
\end{description}
If you think you have a better name for something then change the name. Most other people will be thankful.

\subsection{Functions}
When you write functions bear in mind that they should follow these rules:
\begin{description}
	\item[Small!] Functions should be really small! They should be two three or four lines long if at all possible.\\
		This implies that calls inside \code{if}s and loops should typically be their own function.
	\item[Do one Thing] Don't do multiple things - this makes function naming harder as well.
	\item[One Level of Abstraction] One function splits the one thing stated as function name apart - the parts of the next level of abstraction. Never mix levels of abstraction in one function.
	\item[Stepdown Rule] The first (topmost) function in a class should be the broadest function. The first function inside it should be the one following it and so on. This guarantees a natural flow of reading - from the high level concepts to the details.
	\item[switch -> Polymorphism] Often switch statements can be avoided by using different classes instead of different values. But if not then the switch statement should introduce different classes with different behavior. Most importantly: Never repeat switch statements.
	\item[Descriptive Names] THe more descriptive a name is the less someone has to read the code to understand what it does. A clear long name is better than a cryptic short name.
	\item[Few Arguments] Functions should take few arguments - best none. Anything beyond three arguments needs really good justification. The problem is that you need a closer look to understand all the arguments as they are not obvious anymore. Also testing a function gets exponentially more complicated.
	\item[Output Arguments] Try to avoid them - use return values instead.
	\item[Flags] Flags advertize that a function does more than one thing. Create individual functions for these options.
	\item[Argument Objects] If you use more than two or three arguments you might consider wrapping them in their own class.
	\item[Argument Lists] Lists count as one argument.
	\item[Verbs and Keywords] Monads take verbal names (with nouns as arguments). Nouns in the function name may clear up argument ordering.
	\item[Side Effects] Functions should only do what they are expected to do. Unexpected side effects are hard to debug.
	\item[Output Arguments] Avoid output arguments whenever possible - arguments are always seen as input.
	\item[Comman Query Separation] Something that changes an object shouldn't return anything. It typically confuses the reader of the code.
	\item[Exceptions vs. Error Codes] Exceptions make for cleaner code than error codes which we need to check for every function individually. Therefore prefer exceptions. Also a class defining the error codes is a dependency magnet and if it changes lots of the code needs recompilation/-deploying.
	\item[Error handling is one thing] So use one single function just to handle the errors.
	\item[DRY] Don't repeat yourself. Repetition is a big source of evil. You fix a bug in one place but not in the other. Such problems can occur so easily.
	\item[Structured Programming] Dijkstra said there should only be one entry and one exit to a function - i.e. one \code{return} statement, no \code{break} and \code{continue} statements and no \code{goto}s. Often this is good advice - but as often it's cleaner to sprinkle them in the functions. Just as long as it helps the readability of a function.
\end{description}
How to end up with functions like this? Write messy code but also write unit tests for it. Then massage the messy code until it follows the guidelines and still fulfill the unit tests.

\subsection{Comments}
Comments are used to compensate for our failure to express ourselves in code. This is emphasized in these two points:
\begin{description}
	\item[Comments don't make up for bad code] If you find yourself unable to read some code clean it up and make it legible instead of commenting what it does.
	\item[Explain yourself in code] If it is not obvious what some lines of code do maybe you should make a function that you can name. This is better than writing a comment.
\end{description}
\paragraph{Good Comments:}
\begin{description}
	\item[Legal Comments] Copyrights and similar should be stated at the start of the files.
	\item[Informative Comments] Used to inform about things that can't be conveyed in code - e.g. what a Regex matches.
	\item[Explanation of Intent] If it is not obvious why one would do what is done - e.g. why is a specific value returned.
	\item[Clarifiction] Clear up obscure code flow - e.g. \code{a.compare(b) == -1; // a < b}.
	\item[Warning of Consequence] If it's not obvous what consequences actions could have - e.g. thread safety.
	\item[TODO] Sometimes it's reasonable to leave todos in the code. But there should be a resolve date in sight. Otherwise the code just stays incomplete and you will forget that it is.
	\item[Amplification] There is a really important part of code that might be overlooked if not marked properly.
	\item[Javadocs in public APIs] Write good Javadoc for APIs. These are important for someone else to understand how to use your code.
\end{description}
\paragraph{Bad Comments:}
\begin{description}
	\item[Mumbling] Don't just leave something behind. Either think about your comment or leave it be.
	\item[Redundant Comments] If code is clear and obvious you don't need to write a comment about it - it's redundant. This happens often with Javadocs.
	\item[Misleading Comments] Don't misinform readers. Be precise about your comments. E.g. when and if are two different things.
	\item[Mandated Comments] If your team writes Javadoc for every function you will see tons of comments that are heavily redundant. People will forget to update them which leads to misinformation.
	\item[Journal Comments] Don't write down changes at the top of a file like a change log. You have source code versioning for that.
	\item[Noise Comments] We have a habbit of ignoring irrelevant comments. May it be comments for members or just plain useless comments (e.g. \code{// Give me a break!}).
	\item[Scary Noise] Javadoc can also be scary if you have copy-paste errors in them (renamed the member but not the comment).
	\item[Position Markers] You'll learn to ignore them soon if they are used too often. So only use them if there is a really good reason.
	\item[Closing Brace] Your IDE will (hopefully) tell you where the brace started and therefore you don't need the comment.
	\item[Attributions and Bylines] Don't annotate who added code. That's what your source control is for.
	\item[Commented-Out Code] That code will go stale really fast and nobody will have the courage to delete it. So don't let it lie around.
	\item[HTML Commments] The IDE should design how it displays information gathered from a comment - not the programmer - HTML is wrong here.
	\item[Nonlocal information] Comments should describe code in their neighborhood. If the code is far away nobody will realize the comment is out of date and it will become wrong (e.g. default settings in getters).
	\item[Too Much Information] Nobody reads huge comments. Keep it crisp and clear.
	\item[Inobvious Connection] Don't expect the reader to understand all the details of the subsystem. Comments should be understandable without.
	\item[Javadocs in Nonpublic Code] It's overhead to maintain and will become stale easily - and most often will not hold much information.
\end{description}
If you can rephrase your code in a way that contains your comment that's always better. This may include removing call chains and naming intermediates or extracting a whole method so you can name what you're doing.

\subsection{Formatting}
We format our code to make it clear and easy to read.
\begin{description}
	\item[Vertical Size] Huge files are hard to keep in your mind completely. Therefore aim for shorter files - typically around 200 lines with an upper limit of 500.
	\item[Newspaper Metaphor] First you should write a headline - a name that says what the file does. Following should be a "paragraph" that gives you the high-level story - the first couple of lines of code. Detail should come the further you read down the file.
	\item[Vertical Openness] Blank lines should separate different concepts or parts of a file.
	\item[Vertical Density] Lines of code next to each other should imply close association.
	\item[Vertical Distance] Concepts closely related should stay close vertically. E.g. functions calling each other should stay close.
	\item[Local Variables] should tend to be declared at the top of the function.
	\item[Member Variables] should be declared at the top of the class. If not there do it at the bottom - but at least not separated and not in the middle somewhere.
	\item[Dependent Functions] A function called by another should be close to the other and below the caller. (Non-Book: In C++ you may either declare functions above and define them below a caller or reverse the rule that callees should be just above callers. But decide for one concept and stick with it.)
	\item[Conceptual Affinity] Some functions are similar by concept. Have them close by each other vertically.
	\item[Horizontal Formating] Prefer shorter lines - but long lines are not evil. 80 - 120 characters can be fine but beyond it's probably wrong.
	\item[Horizontal Openness and Density] Adding and not adding white spaces accentuate what is important in a line and what not. E.g. precedence of operators, what operator is used.
	\item[Horizontal Alignment] Aligning assignments is not useful as it emphasizes the wrong thing (name rather than type) and separates name from value. Prefer grouping the entries vertically than aligning them horizontally.
	\item[Indentation] We rely heavily on properly indented code. It might be confusing if it's not. Also resist the temptation to break indentation for small if statements or constructors.
	\item[Dummy Scopes] Don't just add a semicolon on the end of a while loop. This is not clear. Best add proper braces and an empty block. If you prefer the semicolon put it on its own line and indent it properly.
	\item[Team Rules] Define what your team likes as a coding style. Put this into your IDE and stick with it.
\end{description}

\subsection{Objects and Data Structures}

\subsection{Error Handling}

\subsection{Boundaries}

\subsection{Unit Tests}

\subsection{Classes}


\section{Case Studies}

\subsection{Systems}

\subsection{Emergence}

\subsection{Concurrency}

\subsection{Successive Refinement}

\subsection{JUnit Internals}

\subsection{Refactoring SerialDate}


\section{Heuristics and Smells}

\subsection{Comments}

\subsection{Environment}

\subsection{Functions}

\subsection{General}

\subsection{Java}

\subsection{Names}

\subsection{Tests}

\end{document}
